// Generated by CoffeeScript 1.9.1
var angular, io, ngmaterial, reporterApp;

angular = require("angular");

require("angular-animate");

require("angular-aria");

require("angular-treemendous");

ngmaterial = require("angular-material");

io = require("socket.io-client");

require("./index.css");

reporterApp = angular.module("reporterApp", [ngmaterial, "treemendous"]);

reporterApp.controller("appCtrl", function($scope, $mdToast, $sce) {
  var addtotree, levels, loaded, parse, parseConsole, reload, reset, socket;
  socket = io();
  reset = function() {
    $scope.data = [];
    $scope.tree = {
      level: [],
      branches: []
    };
    $scope.failed = [];
    return $scope.console = [];
  };
  reset();
  levels = [];
  $scope.count = 0;
  $scope.tests = 0;
  socket.on("reload", function() {
    console.log("reloading");
    return document.location.reload();
  });
  $scope.splitNewLine = function(string) {
    return string.split("\n");
  };
  parse = function(data) {
    var count, difference, identifier, j, len, lvl, newlevels;
    if (data && data[0]) {
      if (data[0] === "start") {
        reset();
        count = data[0][1].total;
      } else if (data[0] === "fail") {
        $scope.failed.push(data[1]);
      } else if (data[0] === "pass") {
        $scope.data.push(data[1]);
      } else if (data[0] === "end") {
        $scope.count = $scope.data.length;
        $scope.tests = data[1].tests;
        $mdToast.show($mdToast.simple().content('Test finished'));
        loaded();
      }
      if (data[0] === "fail" || data[0] === "pass") {
        if (data[1].levels) {
          return data[1];
        } else {
          identifier = data[1].fullTitle.replace(data[1].title, "").replace(/\s+$/, "");
          difference = identifier;
          newlevels = [];
          for (j = 0, len = levels.length; j < len; j++) {
            lvl = levels[j];
            if (identifier.indexOf(lvl) > -1) {
              difference = difference.replace(lvl, "").replace(/^s+/, "");
              newlevels.push(lvl);
            }
          }
          if (difference) {
            newlevels.push(difference);
          }
          data[1].levels = newlevels;
          levels = newlevels.slice();
          return data[1];
        }
      }
    }
  };
  addtotree = function(data) {
    var branch, current, found, j, k, last, len, len1, level, lvl, newBranch, ref, ref1;
    if (data.levels) {
      current = $scope.tree;
      last = null;
      ref = data.levels;
      for (j = 0, len = ref.length; j < len; j++) {
        lvl = ref[j];
        found = false;
        ref1 = current.branches;
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          branch = ref1[k];
          if (branch.name === lvl) {
            last = current;
            current = branch;
            found = true;
            break;
          }
        }
        if (!found) {
          last = current;
          level = current.level.slice(0);
          level.push(level.length);
          newBranch = {
            name: lvl,
            branches: [],
            leaves: [],
            level: level
          };
          current.branches.push(newBranch);
          current = newBranch;
        }
      }
      return current.leaves.push(data);
    }
  };
  parseConsole = function(consoleChunk) {
    if (!consoleChunk.text) {
      return $sce.trustAsHtml("<br>");
    }
    return $sce.trustAsHtml(consoleChunk.text.replace(/ /g, "&nbsp;"));
  };
  socket.on("data", function(data) {
    var dataChunk, j, len, parsed;
    for (j = 0, len = data.length; j < len; j++) {
      dataChunk = data[j];
      parsed = parse(dataChunk);
      if (parsed) {
        addtotree(parsed);
      }
    }
    return $scope.$$phase || $scope.$digest();
  });
  socket.on("dataChunk", function(dataChunk) {
    var parsed;
    parsed = parse(dataChunk);
    if (parsed) {
      addtotree(parsed);
    }
    return $scope.$$phase || $scope.$digest();
  });
  socket.on("console", function(console) {
    var consoleChunk, i, j, len;
    for (i = j = 0, len = console.length; j < len; i = ++j) {
      consoleChunk = console[i];
      consoleChunk.id = i;
      consoleChunk.text = parseConsole(consoleChunk);
      $scope.console.push(consoleChunk);
    }
    return $scope.$$phase || $scope.$digest();
  });
  socket.on("consoleChunk", function(consoleChunk) {
    consoleChunk.id = $scope.console.length;
    consoleChunk.text = parseConsole(consoleChunk);
    $scope.console.push(consoleChunk);
    return $scope.$$phase || $scope.$digest();
  });
  socket.on("errorChunk", function(errorChunk) {
    var d, j, len, ref, results;
    ref = $scope.failed;
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      d = ref[j];
      if (d.failure && d.failure === errorChunk.id) {
        results.push(d.failure = errorChunk.text.join("\n"));
      } else {
        results.push(void 0);
      }
    }
    return results;
  });
  reload = function() {
    socket.emit("data");
    return socket.emit("console");
  };
  loaded = function() {
    return socket.emit("loaded");
  };
  reload();
  return socket.on("reconnect", reload);
});

reporterApp.filter("hasProperty", function() {
  return function(array, property) {
    var j, len, obj, result;
    if (property) {
      result = [];
      for (j = 0, len = array.length; j < len; j++) {
        obj = array[j];
        if (obj[property]) {
          result.push(obj);
        }
      }
      return result;
    } else {
      return array;
    }
  };
});
